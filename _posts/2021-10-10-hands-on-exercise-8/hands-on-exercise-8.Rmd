---
title: "Hands-on Exercise 8"
description: |
  In Hands-on Exercise 8, I have learnt how to perform geographical segmentation by using appropriate R packages.I have also been exposed to R packages for performing cluster analysis and visualising clustering results.
author:
  - name: Wong Wei Ling
    url: www.google.com
date: 10-10-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_float: true
    number_sections: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


# 1 The Analytical Question

In geobusiness and spatial policy, it is a common practice to delineate the market or planning area into homogeneous regions by using multivariate data. In this hands-on exercise, we are interested to delineate Shan State, Myanmar into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.

# 2 Dataset

Two data sets will be used in this study. They are:

- Myanmar Township Boundary Data (i.e. myanmar_township_boundaries) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.
- Shan-ICT.csv: This is an extract of The 2014 Myanmar Population and Housing Census Myanmar at the township level.

Both data sets are download from Myanmar Information Management Unit (MIMU)

# 3 Install and Load Packages

- Spatial data handling

    + sf, rgdal and spdep
    
- Attribute data handling

    + tidyverse, especially readr, ggplot2 and dplyr
  
- Choropleth mapping

    + tmap
- Multivariate data visualisation and analysis

    + coorplot, ggpubr, and heatmaply
    
- Cluster analysis

    + cluster

```{r echo=TRUE, eval=TRUE}
packages = c('rgdal', 'spdep', 'tmap', 'sf', 'ggpubr', 'cluster', 'factoextra', 'NbClust', 'heatmaply', 'corrplot', 'psych', 'tidyverse')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
    }
  library(p,character.only = T)
}
```

# 4 Data Import and Preparation

## 4.1 Importing geospatial data into R environment

- The Myanmar Township Boundary GIS data is in ESRI shapefile format.
- Use *st_read()* function of **sf** package.

```{r echo=TRUE, eval=TRUE}
shan_sf <- st_read(dsn = "data/geospatial", layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)"))
```

## 4.2 View newly created sf dataframe

- View shan_sf 
- Since shan_sf is conformed to tidy framework, we can also *glimpse()* to reveal the data type of it’s fields.

```{r echo=TRUE, eval=TRUE}
shan_sf
glimpse(shan_sf)
```

## 4.3 Importing aspatial data into R environment

- Use *read_csv()* function of **readr** package
- It is saved in R’s * tibble data.frame* format.
- Use *summary()* to reveal the summary statistics of ict data.frame

```{r echo=TRUE, eval=TRUE}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")

summary(ict)
```

Results above show that:

- There are a total of eleven fields and 55 observation in the tibble data.frame.

## 4.4 Derive new variables using dplyr package

- The unit of measurement of the values are number of household.
- Using these values directly will be **bias** by the underlying total number of households.
- In general, the townships with relatively higher total number of households will also have higher number of households owning radio, TV, etc.
- In order to overcome this problem, we will **derive the penetration rate** of each ICT variable
- - Use *summary()* to reveal the summary statistics of ict_derived data.frame

```{r echo=TRUE, eval=TRUE}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 

summary(ict_derived)

```

# 5 Exploratory Data Analysis (EDA)

## 5.1 EDA using statistical graphics

### 5.1.1 Histograms

- Plot the distribution of the variables (i.e. Number of households with radio) 
- Histogram is useful to identify the overall distribution of the data values (i.e. left skew, right skew or normal distribution)

```{r echo=TRUE, eval=TRUE}
ggplot(data=ict_derived, aes(x=`RADIO`)) +
  geom_histogram(bins=20, color="black", fill="light blue")
```

### 5.1.2 Boxplot

- Boxplots are useful to detect if there are outliers.

```{r echo=TRUE, eval=TRUE}
ggplot(data=ict_derived, aes(x=`RADIO`)) +
  geom_boxplot(color="black", fill="light blue")
```

### 5.1.3 Histograms (newly derived variables)

- Plot the distribution of the newly derived variables (i.e. Radio penetration rate)

```{r echo=TRUE, eval=TRUE}
ggplot(data=ict_derived, aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, color="black", fill="light blue")
```

### 5.1.4 Boxplot (newly derived variables)


```{r echo=TRUE, eval=TRUE}
ggplot(data=ict_derived, aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", fill="light blue")
```

### 5.1.4 Multiple Histograms (selected variables)

- Multiple histograms are plotted to reveal the distribution of the selected variables in the ict_derived data.frame
- *ggarange()* function of **ggpubr** package is used to group these histograms together.

```{r echo=TRUE, eval=TRUE}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

## 5.2 EDA using choropleth map

### 5.2.1 Joining geospatial data with aspatial data

- Combine both the geospatial data object (i.e. shan_sf) and aspatial data.frame object (i.e. ict_derived) into one
- Use the *left_join* function of **dplyr** package
- *shan_sf* simple feature data.frame will be used as the base data object and the *ict_derived* data.frame will be used as the join table.
- The unique identifier used to join both data objects is *TS_PCODE*

```{r echo=TRUE, eval=TRUE}
shan_sf <- left_join(shan_sf, ict_derived, by=c("TS_PCODE"="TS_PCODE"))

```

- It is important to note that there is no new output data been created. Instead, the data fields from ict_derived data frame are now updated into the data frame of shan_sf.

### 5.2.2 Preparing a choropleth map

- using the *qtm()* function of **tmap** package to  look at the distribution of Radio penetration rate of Shan State at township

```{r echo=TRUE, eval=TRUE}
qtm(shan_sf, "RADIO_PR")

```

### 5.2.3 Reveal distribution (bias)

- Create two choropleth maps, one for the total number of households (i.e. TT_HOUSEHOLDS.map) and one for the total number of household with Radio (RADIO.map) to  **reveal the distribution shown in the choropleth map above are bias** to the underlying total number of households at the townships

```{r echo=TRUE, eval=TRUE}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) 

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

Results above show that:
 
-  Townships with relatively larger number of households are also showing relatively higher number of radio ownership.

### 5.2.4 Distribution of total number of households and Radio penetration rate

```{r echo=TRUE, eval=TRUE}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins=0, asp=0)
```

Question: Can you identify the differences?

## 5.3 Correlation Analysis

Before we perform cluster analysis, it is important for us to ensure that the cluster variables are not highly correlated.

- Use *corrplot.mixed()* function of **corrplot** package to visualise and analyse the correlation of the input variables.

```{r echo=TRUE, eval=TRUE}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

Results above show that:

- Correlation plot shows that COMPUTER_PR and INTERNET_PR are highly correlated.
- This suggest that only one of them should be used in the cluster analysis instead of both.

# 6 Hierarchy Cluster Analysis

## 6.1 Prepare variables

### 6.1.1 Extrating clustering variables

- To extract the clustering variables from the shan_sf simple feature object into data.frame.

```{r echo=TRUE, eval=TRUE}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

**Note:** Final clustering variables list **does not include variable INTERNET_PR** because it is highly correlated with variable COMPUTER_PR.

### 6.1.2 Change row names

- Change the rows by township name instead of row number 

```{r echo=TRUE, eval=TRUE}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)
```

### 6.1.3 Delete TS.x field

```{r echo=TRUE, eval=TRUE}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

## 6.2 Data Standardisation


```{r echo=TRUE, eval=TRUE}

```


```{r echo=TRUE, eval=TRUE}

```


```{r echo=TRUE, eval=TRUE}

```


