---
title: "Take-Home Exercise 2"
description: |
  To investigate if the distribution of Airbnb listings are affected by location factors and to analyse the impact of COVID-19 on Airbnb business in Singapore.
author:
  - name: Wong Wei Ling
    url: www.google.com
date: 09-30-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_float: true
    number_sections: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
set.seed(1234)
```


# 1 Objectives

- To investigate if the distribution of Airbnb listings are affected by location factors such as near to existing hotels, MRT services and tourist attractions. 
- To analyse the impact of COVID-19 on Airbnb business in Singapore by comparing Airbnb listings data on June 2019 and June 2021

# 2 Dataset

- Airbnb listings for June 2019 and June 2021 from Inside Airbnb.
- Hotels, tourist attractions, MRT services and other appropriate geospatial data sets were supposed to be extracted from SLA OneMap Service by using onemapsgapi. However, due to some issues of creating a onemap account, Prof. Kam has kindly provided us with the data in CSV format. 
- Coastaloutline is used for binding the Singapore boundary which is also provided by Prof. Kam. 
- Sub zones from data.gov.sg 

# 3 Install and Load Packages

```{r echo=TRUE, eval=TRUE}
packages = c('tidyverse', 'sf', 'tmap', 'maptools', 'spatstat', 'raster', 'gridExtra')

for (p in packages){
if(!require(p, character.only = T)){
  install.packages(p)
}
  library(p,character.only = T)
}
```

Explanation on the uses of each package:

- **tidyverse**: For data import and tidying. It also consist of several other packages specified below. 

    + **readr**: For importing CSV files
    + **dplyr**: For data manipulation
    + **ggplot2**: For plotting graphics
    
- **sf:** For importing and processing of geospatial data such as encoding spatial vector data.
    
- **tmap:** For plotting interactive maps

- **maptools:** For maanipulating geospatial data

- **spatstat:** For statistical analysis of spatial data.

- **raster:** For processing geospatial data to plot KDE maps on OpenStreetMap
    
- **gridExtra:** For arranging KDE maps when plotted into grid objects

# 4 Data Import and Preparation for Geospatial Dataset

In this section, we have to import and ensure that the geospatial data is a format that we can use to perform analysis. We have to check if it is being assigned the right CRS and code. Also, since we are working in the boundary of Singapore, we have to ensure that it is in SVY21 as well. 

## 4.1 Import geospatial data set

- *st_read()* of **sf** package to import the geospatial data sets.
- The imported shapefile will be a simple feature Object of sf.

```{r echo=TRUE, eval=TRUE}
mrt_sf <- st_read(dsn = "data/geospatial", layer = "MRTLRTStnPtt")
mpsz_sf <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_WEB_PL")
sg_sf <- st_read(dsn = "data/geospatial", layer="CostalOutline")
```

From the results above: 

- The geometry type is point, multipolygon and polygon for the mrt, mpsz and sg data set.
- The assigned CRS for all is SVY21.

## 4.2 Check CRS

- Check CRS using *st_crs()* of **sf** package.
- Singapore is using SVY21. 

```{r echo=TRUE, eval=TRUE}
st_crs(mrt_sf)
st_crs(mpsz_sf)
st_crs(sg_sf)

```

From the results above:

- Referencing from *(https://epsg.io/3414)*, the EPSG code of SVY21 is supposed to be 3414.
- The EPSG code shown is 9001 which is incorrect. 

## 4.3 Assign CRS and check again

- *st_set_crs()* of **sf** package to assign correct EPSG code to SpatialPointsDataFrame.
- Do not have to use *st_transform()* since it is already in SVY21. 
- *st_crs* of **sf** package to check the CRS again. 

```{r echo=TRUE, eval=TRUE}
mrt_sf <- st_set_crs(mrt_sf, 3414)
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
sg_sf <- st_set_crs(sg_sf, 3414)

st_crs(mrt_sf)
st_crs(mpsz_sf)
st_crs(sg_sf)

```

## 4.4 Check if geometries are valid

- *st_is_valid()* is used to check for any invalid geometries.

```{r echo=TRUE, eval=TRUE}
length(which(st_is_valid(mrt_sf) == FALSE))
length(which(st_is_valid(mpsz_sf) == FALSE))
length(which(st_is_valid(sg_sf) == FALSE))

```

From the results above: 

- There are 0, 9 and 1 invalid geometries for mrt, mpsz and sg respectively

## 4.5 Handle the invalid geometries and check again

- *st_make_valid()* to make the geometries valid for the mpsz and sg data set only since MRT has no invalid geometries

```{r echo=TRUE, eval=TRUE}
mpsz_sf <- st_make_valid(mpsz_sf)
sg_sf <- st_make_valid(sg_sf)

length(which(st_is_valid(mpsz_sf) == FALSE))
length(which(st_is_valid(sg_sf) == FALSE))
```

Result above show that:

- There are no longer any invalid geometries

## 4.6 Visualise the MRT services on the Singapore map

- It is a good practice to visualise the geospatial data before continuing with the other steps.

```{r echo=TRUE, eval=TRUE}

tm_shape(sg_sf) +
  tm_polygons() +
tm_shape(mpsz_sf) +
  tm_polygons() +
tm_shape(mrt_sf) +
  tm_dots(col="blue")

```


# 5 Data Import and Preparation for Aspatial Dataset

For aspatial data, we have to check for NA values because if NA values are not properly handled, it might hinder with the analysis in the later steps. Additionally, we have to convert them to sf objects and assign them the right CRS, making these data sets suitable to be plotted on a map. 

## 5.1 Import aspatial data sets

- *read_csv()* of **readr** package to import the aspatial data sets.

```{r echo=TRUE, eval=TRUE}
listings_2019 <- read_csv("data/aspatial/listings_June_2019.csv")
hotels <- read_csv("data/aspatial/hotels.csv")
tourism <- read_csv("data/aspatial/tourism.csv")
listings_2021 <- read_csv("data/aspatial/listings_June_2021.csv")

```

## 5.2 Look into the data sets

```{r echo=TRUE, eval=TRUE}
glimpse(listings_2019)
glimpse(hotels)
glimpse(tourism)
glimpse(listings_2021)

```


## 5.3 Data Cleaning

- Remove NA values only from latitude and longitude columns as those are needed for analysis in the later steps.
- NA values in other columns do not have to be dropped as the *data* will be dropped later when converting Spatial* data frame into Spatial* objects.

```{r echo=TRUE, eval=TRUE}
listings_2019 <- listings_2019 %>%
  drop_na(latitude) %>%
  drop_na(longitude)

hotels <- hotels %>%
  drop_na(Lat) %>%
  drop_na(Lng)

tourism <- tourism %>%
  drop_na(LATITUDE) %>%
  drop_na(LONGTITUDE)

listings_2021 <- listings_2021  %>%
  drop_na(latitude) %>%
  drop_na(longitude)

```



## 5.4 Convert Aspatial data frame into sf object and assign CRS

- The values in the latitude & longitude columns are in decimal degrees, hence, this means that it is using WGS84. 
- We then need to assign the epsg code of 4326 before transforming to SVY21.

```{r echo=TRUE, eval=TRUE}
listings_2019_sf <- st_as_sf(listings_2019,
                    coords = c("longitude", "latitude"),
                    crs = 4326)  %>%
  st_transform(crs = 3414)


hotels_sf <- st_as_sf(hotels,
                    coords = c("Lng", "Lat"),
                    crs = 4326)  %>%
  st_transform(crs = 3414)


tourism_sf <- st_as_sf(tourism,
                    coords = c("LONGTITUDE", "LATITUDE"),
                    crs = 4326)  %>%
  st_transform(crs = 3414)

listings_2021_sf <- st_as_sf(listings_2021,
                    coords = c("longitude", "latitude"),
                    crs = 4326)  %>%
  st_transform(crs = 3414)
```


## 5.5 Check CRS

- Check CRS to ensure that it is EPSG:3414 - SVY21

```{r echo=TRUE, eval=TRUE}
st_crs(listings_2019_sf)
st_crs(hotels_sf)
st_crs(tourism_sf)
st_crs(listings_2021_sf)

```

Results above show that:

- All are in the right code of 3414. 

## 5.6 Plot to review (including geospatial data, excluding listings_2021)

- Plot all the point events of Airbnb listings 2019, hotels, tourist attractions and MRT services to ensure that they are being assigned the right CRS. 

```{r echo=TRUE, eval=TRUE}
tm_shape(sg_sf) +
  tm_polygons() +
tm_shape(mpsz_sf) +
  tm_polygons() +
tm_shape(listings_2019_sf) +
  tm_dots(alpha = 0.4,
          col = "blue",
          size = 0.05) +
tm_shape(hotels_sf) +
  tm_dots(alpha = 0.4,
          col = "red",
          size = 0.05) +
tm_shape(tourism_sf) +
  tm_dots(alpha = 0.4,
          col = "green",
          size = 0.05) +
tm_shape(mrt_sf) +
  tm_dots(alpha = 0.4,
          col = "orange",
          size = 0.05)


```


## 5.7 Plot to review (including geospatial data, excluding listings_2019)

- Plot all the point events of Airbnb listings 2021, hotels, tourist attractions and MRT services to ensure that it is being assigned the right CRS. 

```{r echo=TRUE, eval=TRUE}
tm_shape(sg_sf) +
  tm_polygons() +
tm_shape(mpsz_sf) +
  tm_polygons() +
tm_shape(listings_2021_sf) +
  tm_dots(alpha = 0.4,
          col = "blue",
          size = 0.05) +
tm_shape(hotels_sf) +
  tm_dots(alpha = 0.4,
          col = "red",
          size = 0.05) +
tm_shape(tourism_sf) +
  tm_dots(alpha = 0.4,
          col = "green",
          size = 0.05) +
tm_shape(mrt_sf) +
  tm_dots(alpha = 0.4,
          col = "orange",
          size = 0.05)
```


# 6 Geospatial Data Wrangling

This section focuses on converting simple feature data frames to ppp objects that are suitable for the analysis in the later steps. 

## 6.1 Convert sf to Spatial* classes

- *as_Spatial()* of **sf** package is being used to convert the geospatial data from simple feature data frame to spâ€™s Spatial* class.

```{r echo=TRUE, eval=TRUE}
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
listings_2019 <- as_Spatial(listings_2019_sf)
hotels <- as_Spatial(hotels_sf)
tourism <- as_Spatial(tourism_sf)
mrt <- as_Spatial(mrt_sf)
listings_2021 <- as_Spatial(listings_2021_sf)

```


## 6.2 Convert Spatial* dataframe into Spatial* objects

- As *spatstat* requires the analytical data in ppp object and there is no direct way to convert a Spatial* class to ppp object, we have to convert the Spatial classes* into Spatial object first.
- *as()* with the argument *SpatialPoints* of **maptools** package is being used for point data sets, while *SpatialPolygons* is being used for polygonal data sets.
- Data would be dropped in this step.

```{r echo=TRUE, eval=TRUE}
mpsz_sp <- as(mpsz, "SpatialPolygons")
sg_sp <- as(sg, "SpatialPolygons")
listings_2019_sp <- as(listings_2019, "SpatialPoints")
hotels_sp <- as(hotels, "SpatialPoints")
tourisms_sp <- as(tourism, "SpatialPoints")
mrt_sp <- as(mrt, "SpatialPoints")
listings_2021_sp <- as(listings_2021, "SpatialPoints")

```


## 6.3 Convert from Spatial* objects into ppp object

- *as()* with the argument of *ppp* of **maptools** package is being used.
- Project information would be dropped in this step.

```{r echo=TRUE, eval=TRUE}
listings_2019_ppp <- as(listings_2019_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
tourisms_ppp <- as(tourisms_sp, "ppp")
mrt_ppp <- as(mrt_sp, "ppp")
listings_2021_ppp <- as(listings_2021_sp, "ppp")

```

## 6.4 Summary statistics of the newly created ppp objects

```{r echo=TRUE, eval=TRUE}
summary(listings_2019_ppp)
summary(hotels_ppp)
summary(tourisms_ppp)
summary(mrt_ppp)
summary(listings_2021_ppp)

```

- From the results above,

    + Messages about duplicates are printed for listings_2019, hotels & tourism.
    + The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident.


## 6.5 Find number of duplicated points

- sum() and multiplicity() to know the number of locations with more than 1 point event.

```{r echo=TRUE, eval=TRUE}
sum(multiplicity(listings_2019_ppp) > 1)
sum(multiplicity(hotels_ppp) > 1)
sum(multiplicity(tourisms_ppp) > 1)
sum(multiplicity(mrt_ppp) > 1)
sum(multiplicity(listings_2021_ppp) > 1)

```

From the results above:

- All data sets have duplicated points except for the MRT data set.

## 6.6 Handle duplicated points using jitter

- *rjitter()* of **spatstat** package is being used
- To avoid points overlapping, rjitter() will add a small perturbation to the duplicated points so that they do not occupy the exact same space 
- *any()* and *duplicated()* are used to ensure that there are no duplicated points after using *rjitter()*
- From the previous step, even though *mrt_ppp* object is being shown that there are 0 duplicated points, it is a good practice to verify by printing it again.


```{r echo=TRUE, eval=TRUE}
listings_2019_ppp_jit <- rjitter(listings_2019_ppp,
                             retry = TRUE,
                             nsim = 1,
                             drop = TRUE)
any(duplicated(listings_2019_ppp_jit))


hotels_ppp_jit <- rjitter(hotels_ppp,
                             retry = TRUE,
                             nsim = 1,
                             drop = TRUE)
any(duplicated(hotels_ppp_jit))


tourisms_ppp_jit <- rjitter(tourisms_ppp,
                             retry = TRUE,
                             nsim = 1,
                             drop = TRUE)
any(duplicated(tourisms_ppp_jit))


mrt_ppp_jit <- rjitter(mrt_ppp,
                             retry = TRUE,
                             nsim = 1,
                             drop = TRUE)
any(duplicated(mrt_ppp_jit))

listings_2021_ppp_jit <- rjitter(listings_2021_ppp,
                             retry = TRUE,
                             nsim = 1,
                             drop = TRUE)
any(duplicated(listings_2021_ppp_jit))

```

- Results above show that all are FALSE, thereby confirming that there are no duplicated points present after performing *rjitter()*.

## 6.7 Create an owin object

- It is a good practice to confine the spatial point patterns analysis with a geographical area such as the Singapore boundary.
- In **spatstat** package, this polygonal region is known as **owin**, an object specially designed to represent this boundary.

- Convert *sg* SpatialPolygon object to owin object of **spatstat** package 

```{r echo=TRUE, eval=TRUE}
sg_owin <- as(sg_sp, "owin")
```


## 6.8 Combine with owin object

- Combine point, polygonal event object and owin object into one ppp object for Airbnb listings in 2019, 2021, tourisms, hotels and MRT services.

```{r echo=TRUE, eval=TRUE}
listings_2019_ppp = listings_2019_ppp_jit[sg_owin]
tourisms_ppp = tourisms_ppp_jit[sg_owin]
hotels_ppp = hotels_ppp_jit[sg_owin]
mrt_ppp = mrt_ppp_jit[sg_owin]
listings_2021_ppp = listings_2021_ppp_jit[sg_owin]

plot(listings_2019_ppp)
```

## 6.9 Visualise the ppp objects

- *plot()* is being used to visualise the ppp objects which are confined within Singapore boundary

```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,3))

plot(listings_2019_ppp)
plot(tourisms_ppp)
plot(hotels_ppp)
plot(mrt_ppp)
plot(listings_2021_ppp)

```

## 6.10  Re-scale KDE Values

- For the analysis in the later steps, kernel density estimation (KDE) will be computed. 
- However, since the default unit of measurement of SVY21 is in metre, we have to convert the KDE values to kilometre so that the values would not be too small to look for useful insights.
- *rescale()* is used to convert the KDE values from metre to kilometre.

```{r echo=TRUE, eval=TRUE}
listings_2019_ppp.km <- rescale(listings_2019_ppp, 1000, "km")
hotels_ppp.km <- rescale(hotels_ppp, 1000, "km")
tourisms_ppp.km <- rescale(tourisms_ppp, 1000, "km")
mrt_ppp.km <- rescale(mrt_ppp, 1000, "km")
listings_2021_ppp.km <- rescale(listings_2021_ppp, 1000, "km")

```



# 7 Section A: Airbnb Distribution in 2019

This section is to investigate if the distribution of Airbnb listings are affected by location factors such as near to existing hotels, MRT services and tourist attractions. For the purpose of this analysis, Airbnb listings in June 2019 are used. To determine the objective, we will first compute and plot **Kernel Density Estimation maps** then confirm the insights found by using **Second-Order Spatial Point Patterns Analysis** to draw statistical conclusions.


## 7.1 Exploratory Spatial Data Analysis

In this section, we will describe the way in which the expected value of the spatial point patterns varies across space such as the intensity of the spatial point patterns. There are a few ways to measure this property such as Kernel Density Estimation, Nearest Neighbours Index and Quadrat Analysis. For the purpose of this analysis however, we will just be implementing **Kernel Density Estimation**. 

### 7.1.1 Kernel Density Estimation

Kernel Density Estimation is a method to compute the intensity of a point distribution and looks at attribute values across X, Y coordinates (value of attribute value). Geographically, X and Y is the location, which is in projected coordinates system.

#### 7.1.1.1 Plot KDE maps using automatic bandwidth method (ppl)

- *density()* of *spatstat** package is used to plot the re-scaled data set and plot the KDE map

- Bandwidth Selection:

    + Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in their experience, it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. 
    + From the ppp objects plotted above, since there are tight clusters, using ppl would be the most suitable choice.

- Smoothing Kernel:

    + Gaussian is the default and it will be used.
    + It uses a kernel (filter window/moving window) to remove edges and noise from the given data set, such that point events that are located further away will be given less weight. 
    

- Edge argument:

    + This is a logical value to indicate whether to apply edge correction.
    + The default is FALSE.


##### *bw.ppl*

- A function is created to plot KDE maps using the bandwidth *bw.ppl()*
- par() is used to arrange the maps in a side-by-side manner

```{r echo=TRUE, eval=TRUE, fig.width=10, fig.height=8}
kde_ppl <- function(data) {
    density(data,
    sigma=bw.ppl,
    edge=TRUE,
    kernel="gaussian") 
}

par(mfrow=c(2,2))

plot(kde_ppl(listings_2019_ppp.km), main = "listings 2019 bw.ppl")
plot(kde_ppl(hotels_ppp.km), main = "hotels bw.ppl")
plot(kde_ppl(tourisms_ppp.km), main = "tourism bw.ppl")
plot(kde_ppl(mrt_ppp.km), main = "mrt bw.ppl")

```

Results above show that: 

- There is a concentrated area for Hotels and Tourism and a few concentrated areas for MRT services. 
- Listings are generally less concentrated in the same area.

##### Reveal density

- *intensity()* of **spatstat** package is used to reveal the density of Airbnb listings in 2019, Hotels, Tourist Attractions and MRT services.

```{r echo=TRUE, eval=TRUE}
intensity(listings_2019_ppp.km)
intensity(hotels_ppp.km)
intensity(tourisms_ppp.km)
intensity(mrt_ppp.km)

```

Results above show that:

- Airbnb listings in 2019 have the highest density of 11.07 units per km square, followed by hotels, tourism then MRT services which have a density of 0.56, 0.24 and 0.25 units per km square.


#### 7.1.1.2 Data Preparation for visualising Kernel Density Maps on openstreetmap of Singapore

- Kernel density calculates the density of point features around each output raster cell. The steps below show the deriving of kernel density maps being plotted on  openstreetmap of Singapore. 

##### 7.1.1.2.1 Compute KDE maps with metres instead of kilometers

- Since OpenStreetMap's default units is in metres, we have to compute the KDE in metres, instead of using the previously calculated KDE in kilometres. 
- Compute KDE with bw.ppl() using metres.

```{r echo=TRUE, eval=TRUE}
kde_listings_2019_ppl_m <- density(listings_2019_ppp, sigma=bw.ppl, edge=TRUE,kernel="gaussian") 
kde_hotels_ppl_m <- density(hotels_ppp, sigma=bw.ppl, edge=TRUE, kernel="gaussian")
kde_tourism_ppl_m <- density(tourisms_ppp, sigma=bw.ppl, edge=TRUE, kernel="gaussian")
kde_mrt_ppl_m <- density(mrt_ppp, sigma=bw.ppl, edge=TRUE, kernel="gaussian")

```


##### 7.1.1.2.2 Convert KDE output into grid object

- *as.SpatialGridDataFrame.im()* is used so that the gridded output is suitable for mapping.

```{r echo=TRUE, eval=TRUE}
gridded_kde_listings_2019_ppl <- as.SpatialGridDataFrame.im(kde_listings_2019_ppl_m)
gridded_kde_hotels_ppl <- as.SpatialGridDataFrame.im(kde_hotels_ppl_m)
gridded_kde_tourism_ppl <- as.SpatialGridDataFrame.im(kde_tourism_ppl_m)
gridded_kde_mrt_ppl <- as.SpatialGridDataFrame.im(kde_mrt_ppl_m)

```

- Distribution above will be the same, only legend will be different it is being plotted in meters instead of kilometers. 


##### 7.1.1.2.3 Convert gridded output into raster

- Use *raster()* of **raster** package to convert the gridded kernel density objects to RasterLayer object. 

```{r echo=TRUE, eval=TRUE}
kde_listings_2019_ppl_raster <- raster(gridded_kde_listings_2019_ppl)
kde_listings_2019_ppl_raster

kde_hotels_ppl_raster <- raster(gridded_kde_hotels_ppl)
kde_hotels_ppl_raster

kde_tourism_ppl_raster <- raster(gridded_kde_tourism_ppl)
kde_tourism_ppl_raster

kde_mrt_ppl_raster <- raster(gridded_kde_mrt_ppl)
kde_mrt_ppl_raster

```
From the results above: 

- CRS for all data sets are NA. Hence, we have to assign appropriate projection systems. 

##### 7.1.1.2.4 Assign projection systems

- Assign the epsg code of 3414

```{r echo=TRUE, eval=TRUE}
projection(kde_listings_2019_ppl_raster) <- CRS("+init=EPSG:3414")
kde_listings_2019_ppl_raster

projection(kde_hotels_ppl_raster) <- CRS("+init=EPSG:3414")
kde_hotels_ppl_raster

projection(kde_tourism_ppl_raster) <- CRS("+init=EPSG:3414")
kde_tourism_ppl_raster

projection(kde_mrt_ppl_raster) <- CRS("+init=EPSG:3414")
kde_mrt_ppl_raster

```

From the results above: 

- CRS for all data sets are have been assigned appropriate projection systems.


#### 7.1.1.3 Visualise output in openstreetmap

- Create function for plotting the visualisation on OpenStreetMap
- Use **tmap** package to display raster in OpenStreetMap of Singapore.

```{r echo=TRUE, eval=TRUE}
oms <- function(data1, data2, legend1, legend2, main_title) {
  tmap_mode('view')

  tm_basemap("OpenStreetMap")+
    tm_shape(data1) +
    tm_raster("v", title = legend1, alpha= 0.5,  palette = 'Reds' ) +
      tm_shape(data2) + 
      tm_raster("v", title = legend2, alpha= 0.45, palette = 'Blues' )
  
}

```

##### 7.1.1.3.1 Plot Airbnb Listings 2019 against Hotels

- tm_basemap() to specify the visualization to be in OpenStreetMap

```{r echo=TRUE, eval=TRUE}
oms(kde_hotels_ppl_raster, kde_listings_2019_ppl_raster, "Hotels", "Airbnb Listings 2019")

tmap_mode("plot")

```

**Spatial patterns revealed by the kernel density map above:**

- Shades of blue represent Airbnb listings in 2019 while shades of red represent Hotels.
- The shades of the colours shows the number of Airbnb listings and hotels on the map. 
- It is observed that the dark blue colour is prominent in the Southern-Eastern region of Singapore, which indicates a higher number of Airbnb listings in this region. 
- From the intensity of the colours of the blue spots, it can be seen that many Airbnb listings are cluttered in the South-East region. 
- It can also be observed that there is a larger red spot in the same region. This also means that hotels are also dense in the South-East region of Singapore. 


##### 7.1.1.3.2 Plot Airbnb Listings 2019 against Tourist Attractions

```{r echo=TRUE, eval=TRUE}
oms(kde_tourism_ppl_raster, kde_listings_2019_ppl_raster, "Tourism", "Airbnb Listings 2019")

tmap_mode("plot")
```

**Spatial patterns revealed by the kernel density map above:**

- Shades of blue represent Airbnb listing in 2019 while shades of red represent Tourism.
- Similar to the tmap of Airbnb Listings 2019 against Hotels, it can also be observed that the South-East region of Singapore has a high number of tourist attraction and is therefore dense since the red is darker in this region. 
- However, for tourism, it can be seen that it is slightly more concentrated in the middle as compared to hotels which is slightly more spread out. 

<br>

##### 7.1.1.3.3 Plot Airbnb Listings 2019 against MRT services

```{r echo=TRUE, eval=TRUE}
oms(kde_mrt_ppl_raster, kde_listings_2019_ppl_raster, "MRT", "Airbnb Listings 2019")

tmap_mode("plot")
```

**Spatial patterns revealed by the kernel density map above:**

- Shades of blue represent Airbnb listings in 2019 while shades of red represent MRT services.
- Mrt services are dense not only in the same area as the Airbnb listings in 2019, it is also dense in the North-East and North-West region of Singapore. 
- This can be observed from the red spots above. 
- In the South-East region of Singapore, it can be observed that MRT services are not as concentrated as compared to tourism and hotels. MRT services are slightly more spread out within the South-East region of Singapore.
- MRT services is in fact more spread out than hotels within the South-East region of Singapore.

 
<br>

**Advantage of kernel density map over point map:**

- Point map shows all of the occurrences of the point events. It is tough to tell the dense areas from a point map.

- Kernel density maps on the other hand can highlight areas that have high number of the point events. With the help of the shades of colours, the darker it is, the higher the occurrences of these point events. Vice versa, with kernel density maps, areas with lesser point events would not be shown. This means that less prominent spots would not be highlighted in the kernel density map. 

- An advantage of kernel density maps is hence the ability to highlight areas that are dense in the point events (high number of occurrences). 


**Conclusion for Section A's Exploratory Spatial Data Analysis:**

- With kernel density maps however, even though we do see that the distribution of Airbnb listings with hotels, tourist attractions and MRT services are in the same region (with a little variation of the MRT services), we cannot conclude for sure that the distribution of Airbnb listings are affected by the above-mentioned location factors. 
- Hence, we need to employ **Second-order Spatial Point Patterns Analysis** to draw statistical conclusions. 


## 7.2 Second Order Spatial Point Patterns Analysis

A second order spatial point patterns analysis describes the covariance or correlation between values of a spatial point pattern at different regions in space. There are 4 functions available for us to use, namely Cross G-Function, Cross F-Function, Cross K-Function and Cross L-Function. For the purpose of this study, the **Cross L-Function** will be used. 

Cross F-Function will **not** be used as it selects a sample of locations within the study region at random. This means that not all point events will be used for the computation. 

Cross K-Function will **not** be used as we need to look at the curve which might be a little ambiguous. Instead, **Cross L-Function will be used** as it standardizes the curve.

Because of the reasons listed above, **Cross L-Function** would be used.  

### 7.2.1 Prepare and visualise subzones

- Before diving into the computation of the Cross Functions, we first select a sub zone as it is computationally expensive to perform Second Order Spatial Point Patterns Analysis on the entire Singapore.
- Sub zone "DOWNTOWN CORE" will be selected since based on the Exploratory Spatial Data Analysis, most point events for all are clustered around this sub zone. 

- The code chunk below:

    + Specifies the study area to be extracted, which is DOWNTOWN CORE
    + To only take the non NA values
    + Plot the study area using the mpsz data sets to visualise the selected study area.
    
```{r echo=TRUE, eval=TRUE}
mpsz_sf$STUDY_AREA[(mpsz_sf$PLN_AREA_N == 'DOWNTOWN CORE')] = "Y" 

mpsz_sf$STUDY_AREA[is.na(mpsz_sf$STUDY_AREA)] = 'N'

tm_shape(mpsz_sf) +
  tm_fill('STUDY_AREA',
          palette = c('grey', 'lightblue')) +
  tm_borders(col = 'gray28', lwd = 0.1, alpha = 0.3) +
    tm_layout(legend.show = FALSE,
              frame = FALSE)
```

### 7.2.2 Extract selected study areas

#### 7.2.2.1 Create owin for each subzones

- Create function to create owin objects for each sub zones.
- Apply the function created on the selected study area.

```{r echo=TRUE, eval=TRUE}
convert_owin <- function(sz, plan_area) {
  sz[sz$PLN_AREA_N == plan_area,] %>%
    as('Spatial') %>%
    as('SpatialPolygons') %>%
    as('owin')
}

downtowncore_owin <- convert_owin(mpsz_sf, "DOWNTOWN CORE")

```

#### 7.2.2.2 Combine SpatialPoints objects with owin objects

- Combine SpatialPoints object i.e. Airbnb listings in 2019, hotels, tourism and MRT with the downtown core owin object.

```{r echo=TRUE, eval=TRUE}
downtowncore_2019_ppp <- listings_2019_ppp[downtowncore_owin]
downtowncore_hotels_ppp <- hotels_ppp[downtowncore_owin]
downtowncore_tourisms_ppp <- tourisms_ppp[downtowncore_owin]
downtowncore_mrt_ppp <- mrt_ppp[downtowncore_owin]

```

#### 7.2.2.3 Combine the ppp objects

- *superimpose()* of **spatstat** package to combine ppp objects.
- *=* sign is to combine such that the ppp objects are marked. 
- This is necessary for plotting the Cross Functions. 

```{r echo=TRUE, eval=TRUE}
all_downtowncore_ppp <- superimpose(dc_2019_mark=downtowncore_2019_ppp,
                                    dc_hotels_mark=downtowncore_hotels_ppp,
                                    dc_tourisms_mark=downtowncore_tourisms_ppp,
                                    dc_mrt_mark=downtowncore_mrt_ppp)
```


### 7.2.3 Multi-type Point Patterns Analysis: Cross L-Function

#### 7.2.3.1 Compute Cross L-Function Estimation

- Create a function for computing Cross L-Function Estimation

    + *Lcross()* of **spatstat** package is used to compute the Cross L-Function estimation.
    + *plot()* to visualise the relationship.
    
- Finally, the function created is being called to plot the graphs

```{r echo=TRUE, eval=TRUE, fig.width=12, fig.height=8}
par(mfrow=c(2,2))

lcross <- function(data, i, j, title) {
  compute <- Lcross(data, i, j, correction='border')
  
  plot(compute, . - r ~ r, xlab="d", ylab="L(d)-r", main=title)
}

lcross(data = all_downtowncore_ppp, i="dc_2019_mark", j="dc_hotels_mark", title="Listings 2019 vs Hotels Lcross")
lcross(data = all_downtowncore_ppp, i="dc_2019_mark", j="dc_tourisms_mark", title="Listings 2019 vs Tourisms Lcross")
lcross(data = all_downtowncore_ppp, i="dc_2019_mark", j="dc_mrt_mark", title="Listings 2019 vs MRT Lcross")

```

Results above show that:

- There is a sign that the marked spatial point events are not spatially independent at certain distances for all plots.
- However, a hypothesis test is still required to confirm this observation statistically.


#### 7.2.3.2 Perform CSR test on Cross L-Function

- The hypothesis and test are as follows:

    + Ho = The distribution of Airbnb listings in 2019 and Hotels/Tourist Attractions/MRT services are spatially independent.
    + H1 = The distribution of Airbnb listings in 2019 and hotels are **NOT** spatially independent.
    
- The null hypothesis will be rejected if p-value is smaller than alpha value of 0.1 (i.e. at 90% confident interval). (this applies to all of the above points)


#### 7.2.3.3 Monte Carlo test with Cross L-Function

- *envelope()* of **spatstat** package is used to perform CSR test
- A total of 100 simulations will be ran. Using **spatstat** package, the end is always 1 less as the 1st simulation is 0 (and not 1), hence in the argument *nsim*, it is defined as 99 and not 100. 
- A global *set.seed()* is used to ensure that the same output is computed each time the code is being ran. (*set.seed(1234)* is being used and it is placed at the top of the .RMD file, which cannot be seen here.)

```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))

dc_listings_2019_hotels_Lcross.csr <- envelope(all_downtowncore_ppp, Lcross,
                                               i="dc_2019_mark", j="dc_hotels_mark",
                                              correction='border', nsim=99)

dc_listings_2019_tourisms_Lcross.csr <- envelope(all_downtowncore_ppp, Lcross,
                                               i="dc_2019_mark", j="dc_tourisms_mark",
                                              correction='border', nsim=99)

dc_listings_2019_mrt_Lcross.csr <- envelope(all_downtowncore_ppp, Lcross,
                                               i="dc_2019_mark", j="dc_mrt_mark",
                                              correction='border', nsim=99)
```

#### 7.2.3.4  Plot Cross L-Function

- plot() is used to plot the simulated Cross L-Function

```{r echo=TRUE, eval=TRUE, fig.width=12, fig.height=8}
par(mfrow=c(2,2))

plot(dc_listings_2019_hotels_Lcross.csr, . -r ~ r, xlab="distance(m)")
plot(dc_listings_2019_tourisms_Lcross.csr, . -r ~ r, xlab="distance(m)")
plot(dc_listings_2019_mrt_Lcross.csr, . -r ~ r, xlab="distance(m)")

```

Results above show that:

- Red line represents the theoretical curve, the black line represents the observed curve and the grey shaded area represents the envelope derived based on the simulation.

- For Airbnb listings 2019 vs Hotels

    + From about **50 to 150m**, it can be observed that the black line is not only above the red line, it is also above the envelope.  This shows signs of significant cluster pattern from the 50 to 150m mark. Also, since it is above the envelope, we have enough statistical evidence to **reject the null hypothesis** at 90% confidence interval.
    + After the **150m mark**, the black line is below the red line and this shows signs of regular pattern. However, we can only say that it shows sign of significant regular pattern after the 150m mark as this is the part where the black line is below the envelope. Since it is below the envelope, we have enough statistical evidence to **reject the null hypothesis** at 90% confidence interval.
    + To summarise, for both distances i.e.50 to 150m and after the 150m mark, are NOT spatially independent but from **50 to 150m**, it has **significant cluster pattern** while after the **150m mark**, it has **significant regular pattern**.

- For Airbnb listings 2019 vs Tourism

    + The black line is below the red line which shows signs of regular pattern. But it is only significant for ditances **after 250m**.
    + Hence, only for distances **after 250m**, we have enough statistical evidence to **reject the null hypothesis** at 90% confidence interval. We can hence infer that it is NOT spatially independent and for certain distances and has **significant regular patterns.**

- For Airbnb listings 2019 vs MRT

    + The black line is above the red line which shows signs of cluster pattern. But it is only significant at from **160m to 220m**.
    + Hence, only from the distance of **160m to 220m**, we have have enough statistical evidence and we **will reject the null hypothesis** at 90% confidence interval. We can hence infer that it is NOT spatially independent for certain distances.



